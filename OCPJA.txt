https://www.whizlabs.com/ocpjp-scjp/
what is rt.jar?
what is BigDecimal?
What is fail fast fail safe?
What is Enum? example programs
what is equals and hashcode ?
what is javac, javap ?
what is upcasing =>
class A{}  
class B extends A{}  
A a=new B();//upcasting  ===> happens runtime polymorphism
A method is overridden, not the data members, so runtime polymorphism can't be achieved by data members.

class file -> classloader -> Bytecode verified -> Interpreter -> Runtime -> Hardware

=> Runtime Instance - Whenever you write java command on the command prompt to run the java class, an instance of JVM is created.

Classloader
-----------------
1. Bootstrap ClassLoader: This is the first classloader which is the super class of Extension classloader. It loads the rt.jar file which contains all class files of Java Standard Edition like java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes etc.

2.Extension ClassLoader: This is the child classloader of Bootstrap and parent classloader of System classloader. It loades the jar files located inside $JAVA_HOME/jre/lib/ext directory.

3.System/Application ClassLoader: This is the child classloader of Extension classloader. It loads the classfiles from classpath. By default, classpath is set to current directory. You can change the classpath using "-cp" or "-classpath" switch. It is also known as Application classloader.

 If you want to create your own classloader, you need to extend the ClassLoader class.

What is JIT compiler?

3 types of variables in java: local, instance and static.
2 types of data types in Java: primitive and non-primitive.
primitive ---> boolean, char, byte, short, int, long, float and double.	

=> Memory allocation for static variable happens only once when the class is loaded in the memory.

Data Type Default Value Default size
boolean	false	1 bit
char	'\u0000'	2 byte
byte	0	1 byte
short	0	2 byte
int	0	4 byte
long	0L	8 byte
float	0.0f	4 byte
double	0.0d	8 byte

char range -. '\u0000' (or 0) to '\uffff' (or 65,535 inclusive)
byte range - > -128 to 127 (inclusive)
short range -> -32,768 to 32,767 (inclusive)
int range -> - 2,147,483,648 (-2^31) to 2,147,483,647 (2^31 -1) (inclusive)
long range -> -9,223,372,036,854,775,808(-2^63) to 9,223,372,036,854,775,807(2^63 -1)(inclusive)
float -> Its value range is unlimited
double -> Its value range is unlimited

what is bitwise AND	(&) and logical AND(&&)?
The logical && operator doesn't check second condition if first condition is false. It checks second condition only if first one is true.
The bitwise & operator always checks both conditions whether first condition is true or false.

what is 
native?  -> Java native keyword is used to specify that a method is implemented in native code using JNI (Java Native Interface).
what is strictfp?   -> Java strictfp is used to restrict the floating-point calculations to ensure portability.
Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable. The precision may differ from platform to platform that is why java programming language have provided the strictfp keyword, so that you get same result on every platform. So, now you have better control over the floating-point arithmetic.

The strictfp keyword can be applied on methods, classes and interfaces.

strictfp class A{}//strictfp applied on class  
strictfp interface M{}//strictfp applied on interface  
class A{  
strictfp void m(){}//strictfp applied on method  
}  


What is transient: Java transient keyword is used in serialization. If you define any data member as transient, it will not be serialized.

What is volatile: Java volatile keyword is used to indicate that a variable may change asynchronously.


Switch->
The case value must be of switch expression type only. The case value must be literal or constant. It doesn't allow variables.
The case values must be unique. In case of duplicate value, it renders compile-time error.
The Java switch expression must be of byte, short, int, long (with its Wrapper type), enums and string.

Java allows us to use four wrapper classes: Byte, Short, Integer and Long in switch statement.


Syntax for infinitive loop	
for(;;){  
//code to be executed  
}
while(true){  
//code to be executed  
}
do{  
//code to be executed  
}while(true);

Java Labeled For Loop

We can have a name of each Java for loop. To do so, we use label before the for loop. It is useful if we have nested for loop so that we can break/continue specific for loop.

Usually, break and continue keywords breaks/continues the innermost for loop only.


Create Documentation API by javadoc tool:
-----------------------------------------------------
javadoc Calculator.java

====> check programs in javatpoint

Coupling
Cohesion
Association
Aggregation
Composition
  

Coupling
Coupling refers to the knowledge or information or dependency of another class. It arises when classes are aware of each other. If a class has the details information of another class, there is strong coupling. In Java, we use private, protected, and public modifiers to display the visibility level of a class, method, and field. You can use interfaces for the weaker coupling because there is no concrete implementation.

Cohesion
Cohesion refers to the level of a component which performs a single well-defined task. A single well-defined task is done by a highly cohesive method. The weakly cohesive method will split the task into separate parts. The java.io package is a highly cohesive package because it has I/O related classes and interface. However, the java.util package is a weakly cohesive package because it has unrelated classes and interfaces.

Association
Association represents the relationship between the objects. Here, one object can be associated with one object or many objects. There can be four types of association between the objects:

One to One
One to Many
Many to One, and
Many to Many
Let's understand the relationship with real-time examples. For example, One country can have one prime minister (one to one), and a prime minister can have many ministers (one to many). Also, many MP's can have one prime minister (many to one), and many ministers can have many departments (many to many).

Association can be undirectional or bidirectional.

Aggregation
Aggregation is a way to achieve Association. Aggregation represents the relationship where one object contains other objects as a part of its state. It represents the weak relationship between objects. It is also termed as a has-a relationship in Java. Like, inheritance represents the is-a relationship. It is another way to reuse objects.

Composition
The composition is also a way to achieve Association. The composition represents the relationship where one object contains other objects as a part of its state. There is a strong relationship between the containing object and the dependent object. It is the state where containing objects do not have an independent existence. If you delete the parent object, all the child objects will be deleted automatically.


Identity: An object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user. However, it is used internally by the JVM to identify each object uniquely.

A class in Java can contain:
-----------------------------------
Fields
Methods
Constructors
Blocks
Nested class and interface


There are many ways to create an object in java. They are:

By new keyword
By newInstance() method
By clone() method
By deserialization
By factory method etc.

An object which has no reference is known as an anonymous object.

It is not necessary to write a constructor for a class. It is because java compiler creates a default constructor if your class doesn't have any.

Does constructor return any value?
Yes, it is the current class instance (You cannot use return type yet it returns a value).

The static can be:

Variable (also known as a class variable)
Method (also known as a class method)
Block
Nested class

The static variable gets memory only once in the class area at the time of class loading.
A static method can access static data member and can change the value of it.
The static method can not use non static data member or call non-static method directly.

Call to this() must be the first statement in constructor.

Why use inheritance in java
For Method Overriding (so runtime polymorphism can be achieved).
For Code Reusability.

Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice.

https://www.javatpoint.com/method-overloading-in-java (type promotion)


overloading
One type is promoted to another implicitly if no matching datatype is found. 

byte can be promoted to short, int, long, float or double. The short datatype can be promoted to int, long, float or double. The char datatype can be promoted to int,long,float or double and so on.

super() is added in each class constructor automatically by compiler if there is no super() or this().


An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, etc. They are used to provide some essential information to the JVM so that JVM may perform some useful operation.

Access Modifier	within class	within package	outside package by subclass only	outside package
Private	Y	N	N	N
Default	Y	Y	N	N
Protected	Y	Y	Y	N
Public	Y	Y	Y	Y


public final void notify()	wakes up single thread, waiting on this object's monitor.
public final void notifyAll()	wakes up all the threads, waiting on this object's monitor.
public final void wait()throws InterruptedException	causes the current thread to wait, until another thread notifies (invokes notify() or notifyAll() method).


The java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. If we don't implement Cloneable interface, clone() method generates CloneNotSupportedException.

autoboxing and unboxing feature convert primitives into objects and objects into primitives automatically. The automatic conversion of primitive into an object is known as autoboxing and vice-versa unboxing.

The automatic conversion of primitive data type into its corresponding wrapper class is known as autoboxing,


There is only call by value in java, not call by reference. 

compile by > javac CommandLineExample.java  
run by > java CommandLineExample sonoo  
public static void main(String args[]){  
System.out.println("Your first argument is: "+args[0]);  
} 


Regex
//1st way  
Pattern p = Pattern.compile(".s");//. represents single character  
Matcher m = p.matcher("as");  
boolean b = m.matches();  
  
//2nd way  
boolean b2=Pattern.compile(".s").matcher("as").matches();  
  
//3rd way  
boolean b3 = Pattern.matches(".s", "as");  
  
System.out.println(b+" "+b2+" "+b3);  



String to int ===> Interger.parseInt
String to Integer ===> Integer.valueOf()

int to String ===> String.valueOf(), Integer.toString(), String.format()
int i=200;  
String s=String.format("%d",i);   // what is %d
System.out.println(s); 

String to long ======> Long.parseLong()
long to String ====> String.valueOf() and Long.toString()


String to float =====> Float.parseFloat()


The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).

We can throw either checked or uncheked exception in java by throw keyword.

By default Unchecked Exceptions are forwarded in calling chain (propagated).
By default, Checked Exceptions are not forwarded in calling chain (propagated).

Exception Handling is mainly used to handle the checked exceptions. because, unchecked is need to solve.
 If you are calling a method that declares an exception, you must either caught or declare the exception.


Finalize is used to perform clean up processing just before object is garbage collected.
System.gc(); 


Assertion is a statement in java. It can be used to test your assumptions about the program.

While executing assertion, it is believed to be true. If it fails, JVM will throw an error named AssertionError. It is mainly used for testing purpose.
assert expression;  
assert expression1 : expression2;  

Rules for varargs:
While using the varargs, you must follow some rules otherwise program code won't compile. The rules are as follows:

There can be only one variable argument in the method.
Variable argument (varargs) must be the last argument.


   
void method(String... a, int... b){}//Compile time error  
  
void method(int... a, String b){}//Compile time error  


Enum improves type safety
Enum can be easily used in switch
Enum can be traversed
Enum can have fields, constructors and methods
Enum may implement many interfaces but cannot extend any class because it internally extends Enum class

Constructor of enum type is private. If you don't declare private compiler internally creates private constructor.

enum Season{  
WINTER(10),SUMMER(20);  
private int value;  
Season(int value){  
this.value=value;  
}  
} 

Can we have an abstract method in the Enum?
Yes, Of course! we can have abstract methods and can provide the implementation of these methods.

Java Annotation is a tag that represents the metadata i.e. attached with class, interface, methods or fields to indicate some additional information which can be used by java compiler and JVM.

Annotations in Java are used to provide additional information, so it is an alternative option for XML and Java marker interfaces.


Need to study Annotations?


Create Generics Class
------------------------------
class MyGen<T>{  
T obj;  
void add(T obj){this.obj=obj;}  
T get(){return obj;}  
}  

class TestGenerics3{  
public static void main(String args[]){  
MyGen<Integer> m=new MyGen<Integer>();  
m.add(2);  
//m.add("vivek");//Compile time error  
System.out.println(m.get());  
}}  


T - Type
E - Element
K - Key
N - Number
V - Value


Create Generic method

public static < E > void printArray(E[] elements) {  
        for ( E element : elements){          
            System.out.println(element );  
         }  
         System.out.println();  
    }  


Wildcard in Java Generics
The ? (question mark) symbol represents the wildcard element. It means any type. If we write <? extends Number>, it means any child class of Number, e.g., Integer, Float, and double. Now we can call the method of Number class through any child class object.


Literals with a leading zero are octal literals. Any number prefixed with a 0 is considered octal.
Ex:int e = 01_1;  

For Hexadecimal, the 0 x or 0 X is to be placed in the beginning of a number.
Note − Digits 10 to 15 are represented by a to f (A to F) in Hexadecimal.
Ex: int d = 0 x 1_1;

For Binary,   int c = 0B10_10;  
To specify a binary literal, add the prefix 0b or 0B to the integral value.


Lambda expression helps us to write our code in functional style. It provides a clear and concise way to implement SAM interface(Single Abstract Method) by using an expression. 


After having default and static methods inside the interface, we think about the need of abstract class in Java. An interface and an abstract class is almost similar except that you can create constructor in the abstract class whereas you can't do this in interface.

Nashorn is a JavaScript engine. It is used to execute JavaScript code dynamically at JVM (Java Virtual Machine). Java provides a command-line tool jjs which is used to execute JavaScript code.

Diff between Colllectors,Collection
->Collectors.summingDouble
->Collectors.summingInt
->Collectors.averagingDouble
Eg:Double average = productsList.stream()  
                         .collect(Collectors.averagingDouble(p->p.price));  

Optional
public static <T> Optional<T> of(T value)	It returns an Optional with the specified present non-null value.
public static <T> Optional<T> ofNullable(T value)	It returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.

Java Nashorn
var hello = function(){  
    print("Hello Nashorn");  
};  
hello();  

jjs hello.js
or

 // Creating script engine  
        ScriptEngine ee = new ScriptEngineManager().getEngineByName("Nashorn");  
        // Reading Nashorn file  
        ee.eval(new FileReader("js/hello.js"));  


Java 8 feature : Arrays.parallelSort(arr);  


Method Parameter Reflection:
Java provides a new feature in which you can get the names of formal parameters of any method or constructor. The java.lang.reflect package contains all the required classes like Method and Parameter to work with parameter reflection.
javac -parameters Calculate.java  

Collection
------------------
Iterable -> Collection -> List(ArrayList,LinkedList,Vector,Stack), Queue(PriorityQueue), Set(Hashset,LinkedHashset)

Iterator interface provides the facility of iterating the elements in a forward direction only.

Methods in Iterator
1.public boolean hasNext()	It returns true if the iterator has more elements otherwise it returns false.
2.public Object next()	It returns the element and moves the cursor pointer to the next element.
3.public void remove()	It removes the last elements returned by the iterator. It is less used.

Iterable interface  contains only one abstract method. i.e.,
Iterator<T> iterator()  ..

*List*
-------
ArrayList ->  dynamic array to store the duplicate element of different data types. The ArrayList class maintains the insertion order and is non-synchronized.
Java ArrayList allows random access because array works at the index basis.
In ArrayList, manipulation is little bit slower than the LinkedList in Java because a lot of shifting needs to occur if any element is removed from the array list.
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable 

LinkedList - >uses a doubly linked list internally to store the elements. It can store the duplicate elements. It maintains the insertion order and is not synchronized. In LinkedList, the manipulation is fast because no shifting is required.
we can add or remove elements from both sides.
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable 
E peek() -	It retrieves the first element of a list
E poll() - It retrieves and removes the first element of a list.
E pop() - It pops an element from the stack represented by a list.
void push(E e) - It pushes an element onto the stack represented by a list.
E remove() - It is used to retrieve and removes the first element of a list.
LinkedList class can act as a list and queue both because it implements List and Deque interfaces.

Vector -> Vector uses a dynamic array to store the data elements. It is similar to ArrayList. However, It is synchronized and contains many methods that are not the part of Collection framework.

The stack is the subclass of Vector. It implements the last-in-first-out data structure, i.e., Stack. The stack contains all of the methods of Vector class and also provides its methods like boolean push(), boolean peek(), boolean push(object o), which defines its properties.


*Queue*
----------
Queue interface maintains the first-in-first-out order. It can be defined as an ordered list that is used to hold the elements which are about to be processed. There are various classes like PriorityQueue, Deque, and ArrayDeque which implements the Queue interface.

PriorityQueue-> holds the elements or objects which are to be processed by their priorities. PriorityQueue doesn't allow null values to be stored in the queue.

add, element, peek, remove, poll


*Deque*
-----------
Deque interface extends the Queue interface. In Deque, we can remove and add the elements from both the side. Deque stands for a double-ended queue which enables us to perform the operations at both the ends.

ArrayDeque -> class implements the Deque interface. It facilitates us to use the Deque. Unlike queue, we can add or delete the elements from both the ends.

ArrayDeque is faster than ArrayList and Stack and has no capacity restrictions.


*Set*
-------
represents the unordered set of elements which doesn't allow us to store the duplicate items. We can store at most one null value in Set.

HashSet-> represents the collection that uses a hash table for storage. Hashing is used to store the elements in the HashSet. It contains unique items.

LinkedHashset - >extends the HashSet class and implements Set interface. Like HashSet, It also contains unique elements. It maintains the insertion order and permits null elements.

* SortedSet *
-----------------
The elements of the SortedSet are arranged in the increasing (ascending) order. The SortedSet provides the additional methods that inhibit the natural ordering of the elements.


TreeSet -> Like HashSet, TreeSet also contains unique elements. However, the access and retrieval time of TreeSet is quite fast. The elements in TreeSet stored in ascending order.


Ways to iterate the elements of the collection in Java
There are various ways to traverse the collection elements:

By Iterator interface.
By for-each loop.
By ListIterator interface.
By for loop.
By forEach() method.
By forEachRemaining() method.


Java ListIterator Interface
ListIterator Interface is used to traverse the element in a backward and forward direction.

Queue Inerface->
Java Queue interface orders the element in FIFO(First In First Out) manner. In FIFO, first element is removed first and last element is removed at last.
Object peek()	It is used to retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.

Java Deque Interface is a linear collection that supports element insertion and removal at both ends. Deque is an acronym for "double ended queue".
public interface Deque<E> extends Queue<E>  

There are two interfaces for implementing Map in java: Map and SortedMap, and three classes: HashMap, LinkedHashMap, and TreeMap.

HashMap and LinkedHashMap allow null keys and values, but TreeMap doesn't allow any null key or value.

Entry is the subinterface of Map. So we will be accessed it by Map.Entry name. It returns a collection-view of the map, whose elements are of this class. It provides methods to get key and value.

//Returns a Set view of the mappings contained in this map        
      map.entrySet()  
      //Returns a sequential Stream with this collection as its source  
      .stream()  
      //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByKey())  
      //Performs an action for each element of this stream  
      .forEach(System.out::println);  

 //Sorted according to the provided Comparator  
      .sorted(Map.Entry.comparingByKey(Comparator.reverseOrder()))  
     
.sorted(Map.Entry.comparingByValue())  

.sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))  

HashMap in Java is like the legacy Hashtable class, but it is not synchronized. It allows us to store the null elements as well, but there should be only one null key.

Java HashMap contains values based on the key.
Java HashMap contains only unique keys.
Java HashMap may have one null key and multiple null values.
Java HashMap is non synchronized.
Java HashMap maintains no order.
The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable 

What is Hashing
It is the process of converting an object into an integer value. The integer value helps in indexing and faster searches.

equals(): It checks the equality of two objects. It compares the Key, whether they are equal or not. It is a method of the Object class. It can be overridden. If you override the equals() method, then it is mandatory to override the hashCode() method.
hashCode(): This is the method of the object class. It returns the memory reference of the object in integer form. The value received from the method is used as the bucket number. The bucket number is the address of the element inside the map. Hash code of null Key is 0.
Buckets: Array of the node is called buckets. Each node has a data structure like a LinkedList. More than one node can share the same bucket. It may be different in capacity.

The default size of HashMap is 16 (0 to 15).
 
https://www.javatpoint.com/working-of-hashmap-in-java

Java LinkedHashMap class is Hashtable and Linked list implementation of the Map interface, with predictable iteration order.

Java LinkedHashMap contains values based on the key.
Java LinkedHashMap contains unique elements.
Java LinkedHashMap may have one null key and multiple null values.
Java LinkedHashMap is non synchronized.
Java LinkedHashMap maintains insertion order.
The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>  

Java TreeMap class is a red-black tree based implementation. It provides an efficient means of storing key-value pairs in sorted order.

The important points about Java TreeMap class are:

Java TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
Java TreeMap contains only unique elements.
Java TreeMap cannot have a null key but can have multiple null values.
Java TreeMap is non synchronized.
Java TreeMap maintains ascending order.

public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, Serializable

1) HashMap can contain one null key.	TreeMap cannot contain any null key.
2) HashMap maintains no order.	TreeMap maintains ascending order.

Java Hashtable class implements a hashtable, which maps keys to values. It inherits Dictionary class and implements the Map interface.

Points to remember
A Hashtable is an array of a list. Each list is known as a bucket. The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
Java Hashtable class contains unique elements.
Java Hashtable class doesn't allow null key or value.
Java Hashtable class is synchronized.
The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.Java Hashtable class implements a hashtable, which maps keys to values. It inherits Dictionary class and implements the Map interface.

Points to remember
A Hashtable is an array of a list. Each list is known as a bucket. The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
Java Hashtable class contains unique elements.
Java Hashtable class doesn't allow null key or value.
Java Hashtable class is synchronized.
The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.Java Hashtable class implements a hashtable, which maps keys to values. It inherits Dictionary class and implements the Map interface.

Points to remember
A Hashtable is an array of a list. Each list is known as a bucket. The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
Java Hashtable class contains unique elements.
Java Hashtable class doesn't allow null key or value.
Java Hashtable class is synchronized.
The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.Java Hashtable class implements a hashtable, which maps keys to values. It inherits Dictionary class and implements the Map interface.

Points to remember
A Hashtable is an array of a list. Each list is known as a bucket. The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
Java Hashtable class contains unique elements.
Java Hashtable class doesn't allow null key or value.
Java Hashtable class is synchronized.
The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.Java Hashtable class implements a hashtable, which maps keys to values. It inherits Dictionary class and implements the Map interface.

Points to remember
A Hashtable is an array of a list. Each list is known as a bucket. The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
Java Hashtable class contains unique elements.
Java Hashtable class doesn't allow null key or value.
Java Hashtable class is synchronized.
The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.

public class Hashtable<K,V> extends Dictionary<K,V> implements Map<K,V>, Cloneable, Serializable 

Map m = Collections.synchronizedMap(hashMap);
Iterator in HashMap is fail-fast.	Enumerator in Hashtable is not fail-fast.

Collections class->  
Java collection class is used exclusively with static methods that operate on or return collections. It inherits Object class.

The important points about Java Collections class are:

Java Collection class supports the polymorphic algorithms that operate on collections.
Java Collection class throws a NullPointerException if the collections or class objects provided to them are null.
  
String class and Wrapper classes implement the Comparable interface. So if you store the objects of string or wrapper classes, it will be Comparable.public void sort(List list): is used to sort the elements of List. List elements must be of the Comparable type.


public void sort(List list, Comparator c): is used to sort the elements of List by the given Comparator.
Using java 8 ->
Comparator<Student> cm1=Comparator.comparing(Student::getName);  
   Collections.sort(al,cm1);  
Comparator<Student> cm2=Comparator.comparing(Student::getAge);  
Collections.sort(al,cm2);  


If contains null,

ArrayList<Student> al=new ArrayList<Student>();    
 al.add(new Student(101,"Vijay",23));    
 al.add(new Student(106,"Ajay",27));    
 al.add(new Student(105,null,21));    
 Comparator<Student> cm1=Comparator.comparing(Student::getName,Comparator.nullsFirst(String::compareTo));  
  Collections.sort(al,cm1);  
Comparator<Student> cm2=Comparator.comparing(Student::getName,Comparator.nullsLast(String::compareTo));  
  Collections.sort(al,cm2);








Inner Class
---------------
Nested classes represent a special type of relationship that is it can access all the members (data members and methods) of outer class including private.

Nested Class is 2 type.
 1. non static nested class(inner class) 2. static nested class
non static nested class is 3 type.

The non-static nested classes are also known as inner classes.

1.Non-static nested class (inner class)
   1.1Member inner class
    1.2Anonymous inner class
    1.3Local inner class
2.Static nested class

Member Inner Class -> A class created within class and outside method.
Anonymous Inner Class -> A class created for implementing interface or extending class. Its name is decided by the java compiler.
Local Inner Class->	A class created within method.
Static Nested Class-> A static class created within class.
Nested Interface ->An interface created within class or interface.

Anonymous Inner Class
--------------------------------
Person p=new Person(){  
void eat(){System.out.println("nice fruits");}  
};  
A class is created but its name is decided by the compiler which extends the Person class and provides the implementation of the eat() method.
An object of Anonymous class is created that is referred by p reference variable of Person type.

Local inner class
---------------------------
A class i.e. created inside a method is called local inner class in java. If you want to invoke the methods of local inner class, you must instantiate this class inside the method.

Local inner class cannot be invoked from outside the method.

Java static nested class
A static class i.e. created inside a class is called static nested class in java. It cannot access non-static data members and methods. It can be accessed by outer class name.

It can access static data members of outer class including private.
Static nested class cannot access non-static (instance) data member or method.


String
------
The java.lang.String class implements Serializable, Comparable and CharSequence interfaces.

CharSequence Interface
The CharSequence interface is used to represent the sequence of characters. String, StringBuffer and StringBuilder classes implement it. It means, we can create strings in java by using these three classes.

The Java String is immutable which means it cannot be changed. Whenever we change any string, a new instance is created. For mutable strings, you can use StringBuffer and StringBuilder classes.

How to create a string object?
There are two ways to create String object:
1.By string literal
2.By new keyword

Each time you create a string literal, the JVM checks the "string constant pool" first. If the string already exists in the pool, a reference to the pooled instance is returned. If the string doesn't exist in the pool, a new string instance is created and placed in the pool. For example:

String s1="Welcome";  
String s2="Welcome";//It doesn't create a new instance 

Why Java uses the concept of String literal?
To make Java more memory efficient (because no new objects are created if it exists already in the string constant pool).
2. by new ->
String s=new String("Welcome");//creates two objects and one reference variable  
In such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal "Welcome" will be placed in the string constant pool. The variable s will refer to the object in a heap (non-pool). 

Why string objects are immutable in java?
Because java uses the concept of string literal.Suppose there are 5 reference variables,all referes to one object "sachin".If one reference variable changes the value of the object, it will be affected to all the reference variables. That is why string objects are immutable in java.

subString() ->
In case of substring startIndex is inclusive and endIndex is exclusive.


Java StringBuffer class is used to create mutable (modifiable) string. The StringBuffer class in java is same as String class except it is mutable i.e. it can be changed.
Java StringBuffer class is thread-safe i.e. multiple threads cannot access it simultaneously. So it is safe and will result in an order.
The capacity() method of StringBuffer class returns the current capacity of the buffer. The default capacity of the buffer is 16. If the number of character increases from its current capacity, it increases the capacity by (oldcapacity*2)+2. For example if your current capacity is 16, it will be (16*2)+2=34.

StringBuffer sb=new StringBuffer("Hello");  
sb.reverse();  
System.out.println(sb);//prints olleH  

StringBuffer sb=new StringBuffer("Hello ");  
sb.insert(1,"Java");//now original string is changed  
System.out.println(sb);//prints HJavaello  

The Java StringBuilder class is same as StringBuffer class except that it is non-synchronized. It is available since JDK 1.5.


String is slow and consumes more memory when you concat too many strings because every time it creates new instance.
StringBuffer is fast and consumes less memory when you cancat strings.

StringBuffer class doesn't override the equals() method of Object class.


many immutable classes like String, Boolean, Byte, Short, Integer, Long, Float, Double etc. In short, all the wrapper classes and String class is immutable. 

Java String intern()

It can be used to return string from memory, if it is created by new keyword. It creates exact copy of heap string object in string constant pool.public class InternExample{  
public static void main(String args[]){  
String s1=new String("hello");  
String s2="hello";  
String s3=s1.intern();//returns string from pool, now it will be same as s2  
System.out.println(s1==s2);//false because reference variables are pointing to different instance  
System.out.println(s2==s3);//true because reference variables are pointing to same instance  
}}  



Advantages of Java Multithreading
1) It doesn't block the user because threads are independent and you can perform multiple operations at the same time.

2) You can perform many operations together, so it saves time.

3) Threads are independent, so it doesn't affect other threads if an exception occurs in a single thread.

Can we start a thread twice
No. After starting a thread, it can never be started again. If you does so, an IllegalThreadStateException is thrown. In such case, thread will run once but for second time, it will throw exception.

public class TestThreadTwice1 extends Thread{  
 public void run(){  
   System.out.println("running...");  
 }  
 public static void main(String args[]){  
  TestThreadTwice1 t1=new TestThreadTwice1();  
  t1.start();  
  t1.start();  
 }  
}  

The join() method waits for a thread to die. In other words, it causes the currently running threads to stop executing until the thread it joins with completes its task.


Daemon thread in java is a service provider thread that provides services to the user thread. Its life depend on the mercy of user threads i.e. when all the user threads dies, JVM terminates this thread automatically.

There are many java daemon threads running automatically e.g. gc, finalizer etc.

jconsole  -> You can see all the detail by typing the jconsole in the command prompt. The jconsole tool provides information about the loaded classes, memory usage, running threads etc.

Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times.

In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again.
It is used in Servlet and JSP where container creates a thread pool to process the request.

ThreadGroup in Java
Java provides a convenient way to group multiple threads in a single object. In such way, we can suspend, resume or interrupt group of threads by a single method call.

Java thread group is implemented by java.lang.ThreadGroup class.

A ThreadGroup represents a set of threads. A thread group can also include the other thread group. The thread group creates a tree in which every thread group except the initial thread group has a parent.

A thread is allowed to access information about its own thread group, but it cannot access the information about its thread group's parent thread group or any other thread groups.

public class ThreadGroupDemo implements Runnable{  
    public void run() {  
          System.out.println(Thread.currentThread().getName());  
    }  
   public static void main(String[] args) {  
      ThreadGroupDemo runnable = new ThreadGroupDemo();  
          ThreadGroup tg1 = new ThreadGroup("Parent ThreadGroup");  
            
          Thread t1 = new Thread(tg1, runnable,"one");  
          t1.start();  
          Thread t2 = new Thread(tg1, runnable,"two");  
          t2.start();  
          Thread t3 = new Thread(tg1, runnable,"three");  
          t3.start();  
               
          System.out.println("Thread Group Name: "+tg1.getName());  
         tg1.list();  
  
    }  
   }  



The shutdown hook can be used to perform cleanup resource or save the state when JVM shuts down normally or abruptly. Performing clean resource means closing log file, sending some alerts or something else. So if you want to execute some code before JVM shuts down, use shutdown hook.

When does the JVM shut down?
The JVM shuts down when:
user presses ctrl+c on the command prompt
System.exit(int) method is invoked
user logoff
user shutdown etc.


How can an object be unreferenced?
There are many ways:

By nulling the reference
By assigning a reference to another
By anonymous object etc.


The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing. This method is defined in Object class as:

protected void finalize(){}

The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects).

The gc() method is used to invoke the garbage collector to perform cleanup processing. The gc() is found in System and Runtime classes.
 System.gc();  


Java Runtime class is used to interact with java runtime environment. Java Runtime class provides methods to execute a process, invoke GC, get total and free memory etc. There is only one instance of java.lang.Runtime class is available for one java application.

The Runtime.getRuntime() method returns the singleton instance of Runtime class.

 Runtime.getRuntime().exec("notepad");//will open a new notepad  
Runtime.getRuntime().exec("shutdown -s -t 0");  

look eclipse for thread

Inter-thread communication in Java
Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other.

Cooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed.It is implemented by following methods of Object class:

wait()
notify()
notifyAll()


Why wait(), notify() and notifyAll() methods are defined in Object class not Thread class?
It is because they are related to lock and object has a lock.  